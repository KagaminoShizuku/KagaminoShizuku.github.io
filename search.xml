<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于C指针</title>
      <link href="/2024/11/27/%E5%85%B3%E4%BA%8EC%E6%8C%87%E9%92%88/"/>
      <url>/2024/11/27/%E5%85%B3%E4%BA%8EC%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1>0. 声明</h1><p>本文需要读者对指针有基本的了解，在叙述方面将会有所省略。</p><h1>1. 基础知识</h1><h2 id="1-1-间接寻址运算符">1.1. 间接寻址运算符&quot;*&quot;</h2><p>&quot;*&quot;在声明指针变量时与其它情况表示的意思不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p; <span class="comment">//告诉电脑p是一个指针</span></span><br><span class="line">*p=a; <span class="comment">//取p所指向的变量值</span></span><br></pre></td></tr></table></figure><h2 id="1-2-指针的基类型">1.2. 指针的基类型</h2><p>指针变量在声明时具有基类型，一个指针变量只能指向具有同一基类型的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p=&amp;a; <span class="comment">//正常</span></span><br><span class="line">p=&amp;b; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><h2 id="1-3-关于NULL">1.3. 关于NULL</h2><p>空指针：值为NULL(注意都要大写)的指针。<br>如果不知道指针指向哪里，建议将其初始化为NULL。这样做的好处：</p><ol><li>明确说明变量是一个指针变量；</li><li>某些编译器为空指针使用不存在的内存地址，这样做可以防止崩溃；</li><li>避免野指针的出现。</li></ol><h1>2. 指针与函数</h1><h2 id="2-1-指针做函数参数">2.1. 指针做函数参数</h2><p>指针做函数参数时，函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; Fuct(*p); <span class="comment">//表示该函数接收一个指针（地址），在调用时传入指针变量或用&quot;&amp;&quot;运算符对变量取的地址</span></span><br></pre></td></tr></table></figure><p>指针变量做函数参数，函数可以直接对该变量进行修改。<br>需要明确的一点是，指针与指针指向变量的值不是一个概念。如这个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *p1,<span class="type">int</span> *p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *temp;</span><br><span class="line">    temp=p1;</span><br><span class="line">    p1=p2;</span><br><span class="line">    p2=temp;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个swap函数仅在内部交换了两个指针变量的指向，它们指向变量的值并未改变，所以这个函数是错误的。</p><h2 id="2-2-函数指针">2.2. 函数指针</h2><p>函数指针是指向函数的指针。函数指针的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; (*p) (形参列表);</span><br><span class="line"><span class="comment">//函数指针的类型和形参列表需与其指向的函数完全一致（不建议省略形参列表），即若有</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">//则可声明指向Func函数的指针</span></span><br><span class="line"><span class="type">int</span> (*f)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">f=Func;<span class="comment">//不带&quot;()&quot;的Func将被理解为函数的入口地址，f存储了Func函数的入口地址</span></span><br></pre></td></tr></table></figure><p>如果不这么写呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">f</span> <span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="comment">//这将声明一个函数，它的返回值是一个整型指针</span></span><br><span class="line"><span class="type">int</span> (*f);</span><br><span class="line"><span class="comment">//这仅仅定义了一个整型指针，跟括号没半毛钱关系</span></span><br></pre></td></tr></table></figure><p>函数指针用于编写通用性更强的函数，如在排序算法中同时支持升序和降序两种排列方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不使用函数指针：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AscendingSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DescendingSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="comment">//如果使用函数指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n,<span class="type">int</span> (*cmp)(<span class="type">int</span>,<span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (cmp(a[j],a[k]))&#123;k=j&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Ascending(<span class="type">int</span> a,<span class="type">int</span> b);&#123;<span class="keyword">return</span> a&lt;b;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Descending</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;&#123;<span class="keyword">return</span> a.b;&#125;</span><br></pre></td></tr></table></figure><p>使用函数指针将大大减少代码的重复性。</p><h1>3. 指针与数组</h1><h2 id="3-1-指针与一维数组">3.1. 指针与一维数组</h2><p>一维数组的数组名就是它第一个元素的首地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;arr[<span class="number">0</span>],arr<span class="comment">//代表同一个地址</span></span><br><span class="line">p=&amp;arr[<span class="number">0</span>];</span><br><span class="line">p=arr;<span class="comment">//这两个表达是等价的</span></span><br></pre></td></tr></table></figure><h2 id="3-2-指针的算术运算">3.2. 指针的算术运算</h2><p>如果指针有意义(指向数组)，则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p++;<span class="comment">//访问下一元素，加的值为sizeof(&lt;type&gt;)</span></span><br><span class="line">p--;<span class="comment">//访问上一元素，减的值为sizeof(&lt;type&gt;)</span></span><br><span class="line">p2-p1;<span class="comment">//计算指针间距离，值为下标距离</span></span><br><span class="line">p&gt;q;<span class="comment">//比较两元素的相对位置</span></span><br></pre></td></tr></table></figure><p>可以看出，指针在某种意义上就是数组的下标，因此可以用指针的算术运算访问数组元素。</p><h2 id="3-3-两个容易混淆的概念">3.3. 两个容易混淆的概念</h2><h3 id="3-3-1-数组指针与指针数组">3.3.1. 数组指针与指针数组</h3><p>优先级上，()&gt;[]&gt;*, 因此</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>];<span class="comment">//先判定()内，p是个指针，类型为int[3],其步长就为3*sizeof(int)</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">3</span>];<span class="comment">//没有括号就先判定[],p是个数组，数组的元素类型为指针，其步长就为sizeof(int*)</span></span><br></pre></td></tr></table></figure><p>由此可见，数组指针就是指向数组的指针，而指针数组就是存储了指针的数组，还挺顾名思义的。</p><h3 id="3-3-2-指针常量与常量指针">3.3.2. 指针常量与常量指针</h3><p>继续顾名思义，指针常量首先得是个常量，其次它才是个指针；而常量指针首先得是个指针，其次它才是个常量。<br>那也就是说，指针常量的地址不可以被修改，而常量指针所指的值不可以被修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> q=&amp;a;<span class="comment">//声明了一个指针常量q，指向a</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p=&amp;a;<span class="comment">//声明了一个常量指针p，指向a</span></span><br><span class="line">*q=<span class="number">10</span>;<span class="comment">//正常，q的指向未改变</span></span><br><span class="line">q=&amp;b;<span class="comment">//报错，q的指向不能改变</span></span><br><span class="line">*p=<span class="number">10</span>;<span class="comment">//报错，p所指向的值不能改变</span></span><br><span class="line">p=&amp;b;<span class="comment">//正常，p原来指向的值未改变</span></span><br></pre></td></tr></table></figure><h2 id="3-4-指针与二维数组">3.4. 指针与二维数组</h2><h3 id="3-4-1-二维数组的行指针">3.4.1. 二维数组的行指针</h3><p>如果把二维数组的每行拆开，则二维数组实际上是一个指针数组，其存储了二维数组每一行对应的一维数组的数组名（首地址）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>][<span class="number">3</span>]--&gt;a[<span class="number">0</span>],a[<span class="number">1</span>]<span class="comment">//a[0]和a[1]都是数组名(地址)</span></span><br><span class="line">a[<span class="number">0</span>]--&gt;a[<span class="number">0</span>][<span class="number">0</span>],a[<span class="number">0</span>][<span class="number">1</span>],a[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">a[<span class="number">1</span>]--&gt;a[<span class="number">1</span>][<span class="number">0</span>],a[<span class="number">1</span>][<span class="number">1</span>],a[<span class="number">1</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>因此，若要给出二维数组的行指针（假设数组是int数组），则指针的基类型应该是一个int数组，其元素个数与列数相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>];</span><br><span class="line">p=a; <span class="comment">//或p=&amp;a[0],这里的a[0]是地址，可以看出a=&amp;a[0](行)</span></span><br></pre></td></tr></table></figure><p>如此声明会将p指向二维数组的第零行（注意此时还没有值）。<br>若想获得某行某列元素的的值，需要再解一次指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p+i;<span class="comment">//指向二维数组行一维数组的数组名(还未解出)</span></span><br><span class="line">*(p+i);<span class="comment">//解出第i行(从0数起)的数组名(地址)</span></span><br><span class="line">*(p+i)+j;<span class="comment">//指向二维数组第i行第j列的元素(还未解出)</span></span><br><span class="line">*(*(p+i)+j);<span class="comment">//解出a[i][j]的值(完成)</span></span><br></pre></td></tr></table></figure><p>若要将行指针作为函数参数，需要声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; Func(<span class="type">int</span> (*p)[row]);<span class="comment">//列数不可省略且必须为常量</span></span><br></pre></td></tr></table></figure><h3 id="3-4-2-二维数组的列指针">3.4.2. 二维数组的列指针</h3><p>二维数组实际上在内存中按一行一行存储，因此二维数组的本质还是一维数组，只不过引入了偏移量的概念。因此第i行第j列(从0数起)的元素实际上就是第i*n+j个元素。因此</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=a;<span class="comment">//p现在是一个一维指针（注意不是指针数组）</span></span><br><span class="line">*(p+i*n+j);<span class="comment">//就是a[i][j]的值</span></span><br></pre></td></tr></table></figure><p>若要将列指针作为函数参数，需要声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; Func(<span class="type">int</span> *p);<span class="comment">//当成一维指针用就好</span></span><br></pre></td></tr></table></figure><h1>4. 指针与字符串</h1><h2 id="4-1-字符数组与字符指针">4.1. 字符数组与字符指针</h2><p>以’\0’结尾的字符数组(char类型)是字符串。('\0’的ASCII码为0，而’0’为48)<br>字符数组可以用逐个赋值的方法初始化，也可以直接赋字符串(需保证长度为字符串长度+1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;hello&quot;</span>;<span class="comment">//这两种赋值方法等价</span></span><br></pre></td></tr></table></figure><p>字符指针 char *p 是指向字符串首地址的指针，与数组的arr=&amp;arr[0]如出一辙。<br>需要注意的是，尽管指针与数组间有极大的相似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p=<span class="string">&quot;Hello&quot;</span>;<span class="comment">//&quot;Hello&quot;这个内容不能修改，因为是常量</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;Hello&quot;</span>;<span class="comment">//str的指向不能修改，因为是数组名(常量)</span></span><br></pre></td></tr></table></figure><h2 id="4-2-字符串的输入">4.2. 字符串的输入</h2><p>常用的命令有scanf,gets与fgets。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);<span class="comment">//这种方法不会包含空格，且末尾回车会留在缓冲区，可用getchar()清空缓冲区</span></span><br><span class="line">gets(str);<span class="comment">//这种方法会包含空格，末尾回车会被读走</span></span><br><span class="line">fgets(str,n,<span class="built_in">stdin</span>);<span class="comment">//这种方法会包含空格，末尾回车会被读走，最多读取n-1个字符，最后会自动加&#x27;\0&#x27;,且可以指定从哪个流读取字符</span></span><br></pre></td></tr></table></figure><h2 id="4-3-字符串处理函数">4.3. 字符串处理函数</h2><p>由于字符串的本质还是数组，因此不能拿它当变量操作。<br>主要用到的字符串处理函数(包含在&lt;string.h&gt;中)<br>注意：这些处理函数全是对字符串进行操作，而非字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(str);<span class="comment">//返回字符串长度，不包含结尾&#x27;\0&#x27;那一位</span></span><br><span class="line"><span class="built_in">strcpy</span>(str1,str2);<span class="comment">//将str2复制到str1，需要str1足够大</span></span><br><span class="line"><span class="built_in">strcat</span>(str1,str2);<span class="comment">//将str2连接到str1后，str1会取消原来末尾的&#x27;\0&#x27;</span></span><br><span class="line"><span class="built_in">strcmp</span>(str1,str2);<span class="comment">//比较str1和str2，从前往后比，直到出现一对不相等的字符，由它们俩的ASCII码的差值决定返回值，故返回值为0表示相等，返回值为正表示str1&gt;str2，返回值为负表示str1&lt;str2</span></span><br></pre></td></tr></table></figure><h2 id="4-4-函数与字符串">4.4. 函数与字符串</h2><p>向函数传递字符串，可以传递字符数组也可以传递字符指针。这两种方法都是传字符串的首地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Read</span><span class="params">(<span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*p==<span class="string">&#x27;M&#x27;</span>)&#123;...&#125;<span class="comment">//读取第一个命令</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要从函数返回字符串，可以用数组或指针做函数形参、从函数返回指向字符串的指针(定义时就声明，一般是已经分配好的地址)。</p><h1>5. 指针与结构体</h1><h2 id="5-1-结构体指针">5.1. 结构体指针</h2><p>结构体指针用结构体名作为类型，指向同种结构体的第一个元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STUDENT stu1;</span><br><span class="line">STUDENT *pt;</span><br><span class="line">pt=&amp;stu1;<span class="comment">//pt指向stu1的第一个元素</span></span><br><span class="line">(*pt).studentID=<span class="number">1</span>;<span class="comment">//相当于stu1.studentID=1</span></span><br></pre></td></tr></table></figure><p>如果是结构体数组，则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STUDENT stu[<span class="number">20</span>];</span><br><span class="line">STUDENT *pt=stu;<span class="comment">//与STUDENT *pt=&amp;stu[0]等价</span></span><br><span class="line">(*pt).studentID=<span class="number">1</span>;<span class="comment">//相当于stu[0].studentID=1</span></span><br><span class="line">pt++;<span class="comment">//将pt指向stu[1]</span></span><br></pre></td></tr></table></figure><h2 id="5-2-向函数传递结构体">5.2. 向函数传递结构体</h2><p>向函数传递结构体可以传递结构体的自身的完整或局部，也可以向函数传递结构体指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Func</span><span class="params">(POINT pt)</span>;<span class="comment">//修改结果不影响到实参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Func</span><span class="params">(POINT *pt)</span>;<span class="comment">//修改结果影响实参</span></span><br></pre></td></tr></table></figure><p>当然，结构体及其指针也可以做函数的返回值，但较推荐返回指针。</p><h1>6. 链表</h1><h2 id="6-1-链表及其创建">6.1. 链表及其创建</h2><p>链表是在结构体内部用这种结构体类型的指针实现散点文件链接存储的数据结构。其结构为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DATA data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，每个节点的指针域存储下一个节点的地址。头指针指向第一个节点，尾节点指针域为NULL。<br>在创建链表的过程中，需要包含以下逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pt=(PLAYER*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PLAYER));<span class="comment">//每次都分配新pt内存</span></span><br><span class="line">prePt-&gt;next=Pt;<span class="comment">//将prePt现在所指结构体的指针域指向Pt所对应的(下一个)节点</span></span><br><span class="line">prePt=Pt;<span class="comment">//将Pt赋值给prePt以进行下次循环</span></span><br></pre></td></tr></table></figure><h2 id="6-2-链表的查找">6.2. 链表的查找</h2><p>查找尾节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PLAYER *<span class="title function_">FindLast</span><span class="params">(PLAYER *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    PLAYER *pr;</span><br><span class="line">    pr=head;<span class="comment">//创建head指针的备份</span></span><br><span class="line">    <span class="keyword">while</span>(pr-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pr=pr-&gt;next;<span class="comment">//若当前不是尾节点，则移动指针到下一个节点：pr-&gt;next会访问下一节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找一般节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PLAYER *<span class="title function_">FindNode</span><span class="params">(PLAYER *head,<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    PLAYER *Pt=head;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;index &amp;&amp; Pt!=<span class="literal">NULL</span>)<span class="comment">//查找到n &amp;&amp; 在链表内</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pt=Pt-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Pt;<span class="comment">//若找到，则正常返回；若超出范围，则返回空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-链表的插入">6.3. 链表的插入</h2><p>向尾节点后面插入节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PLAYER *<span class="title function_">Insert</span><span class="params">(PLAYER *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    PLAYER *prept *pt;</span><br><span class="line">    pt=(PLAYER*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PLAYER));<span class="comment">//为pt分配PLAYER空间用于存储输入</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pt-&gt;account);<span class="comment">//输入pt指向PLAYER空间信息</span></span><br><span class="line">    prept=FindLast(head);<span class="comment">//prept指向为尾节点的头</span></span><br><span class="line">    prept-&gt;next=pt;<span class="comment">//prept的指针域指向pt</span></span><br><span class="line">    pt-&gt;next=<span class="literal">NULL</span>;<span class="comment">//令pt成为新的尾节点</span></span><br><span class="line">    <span class="keyword">return</span> head;<span class="comment">//返回更新后的链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向一般节点后插入节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PLAYER *<span class="title function_">Insert</span><span class="params">(PLAYER *head,<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    PLAYER *prept *pt;</span><br><span class="line">    pt=(PLAYER*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PLAYER));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pt-&gt;account);<span class="comment">//至此同上</span></span><br><span class="line">    prept=FindNode(head,index);<span class="comment">//prept指向index号节点</span></span><br><span class="line">    <span class="keyword">if</span>(prept!=<span class="literal">NULL</span>)<span class="comment">//如果不是空指针</span></span><br><span class="line">    &#123;</span><br><span class="line">    pt-&gt;next=prept-&gt;next;<span class="comment">//将pt的指针域指向prept的下一个节点</span></span><br><span class="line">    prept-&gt;next=pt;<span class="comment">//将prept指向节点的指针域指向pt</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;node not exists&quot;</span>);&#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-链表的删除">6.3. 链表的删除</h2><p>删除节点，就是将节点从链表中摘下来，恢复前后关系后释放节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PLAYER *<span class="title function_">Delete</span><span class="params">(PLAYER *head, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    PLAYER *pt=<span class="literal">NULL</span>,*prept=<span class="literal">NULL</span>;</span><br><span class="line">    prept=FindNode(head,index<span class="number">-1</span>)<span class="comment">//寻找要删除节点的上一个节点，因为前驱节点位置难获取</span></span><br><span class="line">    pt=prept-&gt;next;<span class="comment">//pt指向这个待删除节点</span></span><br><span class="line">    <span class="keyword">if</span>(pt!=<span class="literal">NULL</span>)<span class="comment">//删除的节点是否存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        prept-&gt;next=pt-&gt;next;<span class="comment">//前驱节点的直接指向后继节点，在一般链表的访问中已经无法访问待删除的节点</span></span><br><span class="line">        <span class="built_in">free</span>(pt);<span class="comment">//释放pt指向的空间，删除待删除的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;node not exists&quot;</span>);&#125;</span><br><span class="line">    <span class="keyword">return</span> head;<span class="comment">//返回更新后的链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见这个方法对尾节点也有效。</p><h1>结尾</h1><p>你说得对，但是舞萌DX国服将于12月4日10:00更新「系ぎて」,我要去拆机了</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
