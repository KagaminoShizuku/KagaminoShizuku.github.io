<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>EasyX学习笔记</title>
      <link href="/2024/11/29/easyx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/11/29/easyx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>1. 前言</h1><p>学校C语言大作业，可以写一个信息管理系统，也可以做一个游戏<br>我觉得写信息管理系统太没意思了，于是打算做一个4k音游，要用到图形界面，还得考虑时间成本，于是我选择了EasyX进行图形化界面的实现。<br>下面会写到函数的原型，知道怎么用就可以了不必深挖</p><h1>2. 环境准备</h1><ul><li>Visual Studio 2022</li><li>EasyX_20240601</li></ul><p>VS2022的配置方法不再赘述。<br>从<a href="https://easyx.cn/download/EasyX_20240601.exe">这里</a>下载同款EasyX，下载完成之后打开安装exe跟着走，应该就能看到自动识别的VS2022目录(先装VS2022)，点目录右侧安装即可；<br>还有一个是Easyx的文档，建议也安装看一看毕竟也不大</p><h1>3. EasyX基础</h1><h2 id="3-1-EasyX使用的颜色">3.1. EasyX使用的颜色</h2><p>EasyX可以使用RGB颜色；可以用<a href="https://lzltool.cn/color">RGB在线转换</a>查询颜色。</p><h2 id="3-2-EasyX的坐标">3.2. EasyX的坐标</h2><p>坐标分为物理坐标和逻辑坐标。<br>物理坐标原点(0,0)位于屏幕左上角，以px为单位；<br>逻辑坐标原点(0,0)位于窗口左上角，以px为单位。<br>下述若无特指，均为逻辑坐标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">·----------------&gt;</span><br><span class="line">|              X轴</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">v Y轴</span><br></pre></td></tr></table></figure><h2 id="3-3-EasyX的绘图表面（又称绘图设备）">3.3. EasyX的绘图表面（又称绘图设备）</h2><p>EasyX中绘图表面分为默认的绘图窗口以及IMAGE对象。一旦绘图表面被指定，所有的绘图函数都会绘制在该绘图表面上。</p><h2 id="3-4-常见问题">3.4. 常见问题</h2><h3 id="3-4-1-编译报错，提示EasyX-is-only-for-c">3.4.1. 编译报错，提示EasyX is only for c++</h3><p>字面意思，EasyX使用了C++的特性，而编译.c文件时VC会调用C编译器导致报错。<br>将文件后缀由.c改为.cpp即可解决，C++完全支持C，正常使用即可</p><h3 id="3-4-2-运行报错，提示无法打开-exe进行写入">3.4.2. 运行报错，提示无法打开.exe进行写入</h3><p>这个问题一般是结束程序时点了窗口右上角红叉叉，而实际上程序还在运行，就跟你不能卸载正在运行的游戏一个道理。<br>打开任务管理器，在详细信息页找到进程名结束即可暂时解决此问题；<br>一劳永逸的方法是在VS上方工具栏的“工具”-“选项”-“调试”-“常规”中打开“调试停止时自动关闭控制台”。</p><h1>4. EasyX用法</h1><h2 id="4-1-引入EasyX">4.1.引入EasyX</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;easyx.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="4-2-窗口函数">4.2. 窗口函数</h2><h3 id="4-2-1-窗口的创建">4.2.1. 窗口的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initgraph(<span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> flag);</span><br></pre></td></tr></table></figure><p>width–窗口宽度 height–窗口高度 flag–窗口样式<br>flag可写多个也可不写，不写默认取NULL。<br>flag也可以取如下值：</p><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">EX_DBLCLKS</td><td style="text-align:center">在绘图窗口中支持鼠标双击事件</td></tr><tr><td style="text-align:center">EX_NOCLOSE</td><td style="text-align:center">禁用绘图窗口的关闭按钮</td></tr><tr><td style="text-align:center">EX_NOMINIMIZE</td><td style="text-align:center">禁用绘图窗口的最小化按钮</td></tr><tr><td style="text-align:center">EX_SHOWCONSOLE</td><td style="text-align:center">显示控制台窗口</td></tr></tbody></table><p>例如以下都能创建窗口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">initgraph(<span class="number">640</span>,<span class="number">480</span>);</span><br><span class="line">initgraph(<span class="number">640</span>,<span class="number">480</span>,EX_SHOWCONSOLE);</span><br><span class="line">initgraph(<span class="number">640</span>,<span class="number">480</span>,EX_SHOWCONSOLE | EX_NOCLOSE);</span><br></pre></td></tr></table></figure><h3 id="4-2-2-窗口的关闭">4.2.2. 窗口的关闭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closegraph();</span><br></pre></td></tr></table></figure><p>是的就这点。</p><h3 id="4-2-3-绘图表面的清空">4.2.3. 绘图表面的清空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleardevice();</span><br></pre></td></tr></table></figure><p>使用当前背景色清空绘图设备。</p><h2 id="4-3-绘图函数">4.3. 绘图函数</h2><h3 id="4-3-1-无填充图形的绘制">4.3.1. 无填充图形的绘制</h3><p>几个常用的图形：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制以(x,y)为圆心，radius为半径的圆</span></span><br><span class="line">circle(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> radius);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制以(left,top)为左上角，(right,bottom)为右下角的椭圆(外切矩形的)</span></span><br><span class="line">ellipse(<span class="type">int</span> left,<span class="type">int</span> top,<span class="type">int</span> right,<span class="type">int</span> bottom);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制扇形，在椭圆的基础上strangle为起始角弧度，endangle为终止角弧度</span></span><br><span class="line">pie(<span class="type">int</span> left,<span class="type">int</span> top,<span class="type">int</span> right,<span class="type">int</span> bottom,<span class="type">double</span> stangle,<span class="type">double</span> endangle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制多边形，传入POINT数组，num为多边形顶点的个数，其等于数组中元素个数</span></span><br><span class="line">polygon(<span class="type">const</span> POINT *points,<span class="type">int</span> num);</span><br><span class="line"><span class="comment">//绘制多边形示例</span></span><br><span class="line">POINT pts[] = &#123; &#123;<span class="number">50</span>, <span class="number">200</span>&#125;, &#123;<span class="number">200</span>, <span class="number">200</span>&#125;, &#123;<span class="number">200</span>, <span class="number">50</span>&#125; &#125;;</span><br><span class="line">polygon(pts,<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> pts[] = &#123;<span class="number">50</span>, <span class="number">200</span>,  <span class="number">200</span>, <span class="number">200</span>,  <span class="number">200</span>, <span class="number">50</span>&#125;;</span><br><span class="line">polygon((POINT*)pts, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制以(left,top)为左上角,以(right,bottom)为右下角的矩形</span></span><br><span class="line">rectangle(<span class="type">int</span> left,<span class="type">int</span> top,<span class="type">int</span> right,<span class="type">int</span> bottom);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制圆角矩形，在矩形的基础上ellipsewidth为圆角椭圆宽度，ellipseheight为圆角椭圆高度</span></span><br><span class="line">roundrect(<span class="type">int</span> left,<span class="type">int</span> top,<span class="type">int</span> right,<span class="type">int</span> bottom,<span class="type">int</span> ellipsewidth,<span class="type">int</span> ellipseheight);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制一条连接(x1,y1)和(x2,y2)的线段</span></span><br><span class="line">line(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制一点(x,y),color为颜色</span></span><br><span class="line">putpixel(<span class="type">int</span> x,<span class="type">int</span> y,COLORREF color);</span><br></pre></td></tr></table></figure><h3 id="4-3-2-有-无边框的有填充图形的绘制">4.3.2. 有/无边框的有填充图形的绘制</h3><p>在函数前面加fill–有边框填充<br>在函数前面加solid–无边框填充,如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fillcircle(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> radius);</span><br><span class="line">solidcircle(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> radius);</span><br></pre></td></tr></table></figure><h3 id="4-3-3-绘图颜色及样式设置">4.3.3. 绘图颜色及样式设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置线条样式</span></span><br><span class="line">setlinestyle(<span class="type">int</span> style,<span class="type">int</span> thickness);<span class="comment">//style被预定义了，具体见下表; thickness为线条粗细,这里有所省略，用这些就够了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置线条颜色</span></span><br><span class="line">setlinecolor(COLORREF color);<span class="comment">//COLORREF color被预定义了，具体见下表，也可以用RGB(a,b,c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置填充颜色</span></span><br><span class="line">setfillcolor(COLORREF color);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置背景颜色</span></span><br><span class="line">setbkcolor(COLORREF color);</span><br><span class="line">cleardevice();<span class="comment">//把原来的背景色清除掉</span></span><br></pre></td></tr></table></figure><h4 id="预定义颜色">预定义颜色</h4><table><thead><tr><th style="text-align:center">颜色名称</th><th style="text-align:center">颜色</th><th style="text-align:center">颜色名称</th><th style="text-align:center">颜色</th></tr></thead><tbody><tr><td style="text-align:center">BLACK</td><td style="text-align:center">黑</td><td style="text-align:center">DARKGRAY</td><td style="text-align:center">深灰</td></tr><tr><td style="text-align:center">BLUE</td><td style="text-align:center">蓝</td><td style="text-align:center">LIGHTBLUE</td><td style="text-align:center">亮蓝</td></tr><tr><td style="text-align:center">GREEN</td><td style="text-align:center">绿</td><td style="text-align:center">LIGHTGREEN</td><td style="text-align:center">亮绿</td></tr><tr><td style="text-align:center">CYAN</td><td style="text-align:center">青</td><td style="text-align:center">LIGHTCYAN</td><td style="text-align:center">亮青</td></tr><tr><td style="text-align:center">RED</td><td style="text-align:center">红</td><td style="text-align:center">LIGHTRED</td><td style="text-align:center">亮红</td></tr><tr><td style="text-align:center">MAGENTA</td><td style="text-align:center">紫</td><td style="text-align:center">LIGHTMAGENTA</td><td style="text-align:center">亮紫</td></tr><tr><td style="text-align:center">BROWN</td><td style="text-align:center">棕</td><td style="text-align:center">YELLOW</td><td style="text-align:center">黄</td></tr><tr><td style="text-align:center">LIGHTGRAY</td><td style="text-align:center">浅灰</td><td style="text-align:center">WHITE</td><td style="text-align:center">白</td></tr></tbody></table><h4 id="预定义线条样式">预定义线条样式</h4><table><thead><tr><th style="text-align:center">样式名称</th><th style="text-align:center">样式</th></tr></thead><tbody><tr><td style="text-align:center">PS_SOLID</td><td style="text-align:center">实线</td></tr><tr><td style="text-align:center">PS_DASH</td><td style="text-align:center">-------</td></tr><tr><td style="text-align:center">PS_DOT</td><td style="text-align:center">············</td></tr><tr><td style="text-align:center">PS_DASHDOT</td><td style="text-align:center">-·-·-·-·</td></tr><tr><td style="text-align:center">PS_DASHDOTDOT</td><td style="text-align:center">-··-··-··</td></tr><tr><td style="text-align:center">PS_NULL</td><td style="text-align:center">线不可见</td></tr></tbody></table><h2 id="4-4-文字绘制函数">4.4. 文字绘制函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文字输出</span></span><br><span class="line">outtextxy(<span class="type">int</span> x,<span class="type">int</span> y,LPCTSTR str);<span class="comment">//在(x,y)处输出字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置文字颜色</span></span><br><span class="line">settextcolor(COLORREF color);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置文字样式</span></span><br><span class="line">settextstyle(<span class="type">int</span> height,<span class="type">int</span> width,LPCTSTR fontname);<span class="comment">//height为文字高度，width为文字宽度(0--自适应)，fontname为字体名称，如&quot;楷体&quot;(传了字符串)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置背景模式</span></span><br><span class="line">setbkmode(<span class="type">int</span> mode);<span class="comment">//mode为背景模式，TRANSPARENT(1)--透明(全小写的是EasyX中的)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字符串占用的像素宽/高</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">textheight</span><span class="params">(LPCTSTR str)</span>;<span class="comment">//获取所占高度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">textwidth</span><span class="params">(LPCTSTR str)</span>;<span class="comment">//获取所占宽度</span></span><br></pre></td></tr></table></figure><p>需要注意,outtextxy()函数不能直接传中文字符串。如要传中文字符串：</p><ul><li>在字符串前面加一个大写的’L’,如 L&quot;早上好&quot;</li><li>将字符串改写为TEXT(str),如 TEXT(“早上好”) ,其中TEXT可改写成_T</li><li>(推荐) VS上方工具栏&quot;项目&quot;- “属性”-“高级”，将&quot;字符集&quot;选项改为&quot;使用多字节字符集&quot;</li></ul><h2 id="4-5-图像处理">4.5. 图像处理</h2><h3 id="4-5-1-图像处理的变量类型">4.5.1. 图像处理的变量类型</h3><p>在导入图片时,需要用IMAGE类型定义变量,再将图片加载进变量。</p><h3 id="4-5-2-从文件中读取并展示图像">4.5.2. 从文件中读取并展示图像</h3><p>先看函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loadimage(IMAGE *pDstImg,LPCTSTR pImgfile,<span class="type">int</span> nWidth=<span class="number">0</span>,<span class="type">int</span> nHeight=<span class="number">0</span>,<span class="type">bool</span> bResize=<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//pDstImg:IMAGE类型变量的指针</span></span><br><span class="line"><span class="comment">//pImgfile:图片文件名</span></span><br><span class="line"><span class="comment">//nWidth:图片拉伸到的宽度</span></span><br><span class="line"><span class="comment">//nHeight:图片拉伸到的高度,和nWidth在赋0时表示使用原图信息</span></span><br><span class="line"><span class="comment">//bResize:是否调整IMAGE大小以适应图片</span></span><br></pre></td></tr></table></figure><p>实际应用这么写(要是不放缩图片)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IMAGE img1;</span><br><span class="line">loadimage(&amp;img1,<span class="string">&quot;./src/show.jpg&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面只是加载了图像，用户还看不到，所以有下面的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">putimage(<span class="type">int</span> dstX,<span class="type">int</span> dstY,IMAGE *pSrclmg,DWORD dwRop=SRCCOPY);</span><br><span class="line"><span class="comment">//dstX,dstY:绘制位置的(x,y)坐标</span></span><br><span class="line"><span class="comment">//pSrclmg:要绘制的IMAGE变量的指针</span></span><br><span class="line"><span class="comment">//dwRop=SRCCOPY:三元光栅操作码</span></span><br></pre></td></tr></table></figure><p>实际应用(接上)这么写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putimage(<span class="number">0</span>,<span class="number">0</span>,&amp;img);</span><br></pre></td></tr></table></figure><p>综上，将会在窗口的(0,0)坐标处绘制一个原图大小的src中的show.jpg。</p><h1>5. 鼠标和键盘消息的获取</h1><p>这部分依旧属于EasyX，但键鼠消息获取对游戏很重要，故单独拿出来做笔记</p><h2 id="5-1-消息的变量类型">5.1. 消息的变量类型</h2><p>EasyX中用类型ExMessage定义的变量获取消息。<br>ExMessage的结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExMessage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">USHORT message;<span class="comment">// 消息标识</span></span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 鼠标消息的数据&quot;EX_MOUSE&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">bool</span> ctrl:<span class="number">1</span>;<span class="comment">// Ctrl 键是否按下</span></span><br><span class="line"><span class="type">bool</span> shift:<span class="number">1</span>;<span class="comment">// Shift 键是否按下</span></span><br><span class="line"><span class="type">bool</span> lbutton:<span class="number">1</span>;<span class="comment">// 鼠标左键是否按下</span></span><br><span class="line"><span class="type">bool</span> mbutton:<span class="number">1</span>;<span class="comment">// 鼠标中键是否按下</span></span><br><span class="line"><span class="type">bool</span> rbutton:<span class="number">1</span>;<span class="comment">// 鼠标右键</span></span><br><span class="line"><span class="type">short</span> x;<span class="comment">// 鼠标的 x 坐标</span></span><br><span class="line"><span class="type">short</span> y;<span class="comment">// 鼠标的 y 坐标</span></span><br><span class="line"><span class="type">short</span> wheel;<span class="comment">// 鼠标滚轮滚动值，为 120 的倍数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 按键消息的数据&quot;EX_KEY&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BYTE vkcode;<span class="comment">// 按键的虚拟键码</span></span><br><span class="line">BYTE scancode;<span class="comment">// 按键的扫描码（依赖于 OEM）</span></span><br><span class="line"><span class="type">bool</span> extended:<span class="number">1</span>;<span class="comment">// 按键是否是扩展键</span></span><br><span class="line"><span class="type">bool</span> prevdown:<span class="number">1</span>;<span class="comment">// 按键的前一个状态是否按下</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 字符消息的数据&quot;EX_CHAR&quot;</span></span><br><span class="line">TCHAR ch;</span><br><span class="line">        <span class="comment">// 窗口消息的数据&quot;EX_WINDOW&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">WPARAM wParam;</span><br><span class="line">LPARAM lParam;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中USHORT message消息标识如下:</p><table><thead><tr><th style="text-align:center">消息标识</th><th style="text-align:center">消息类别</th><th style="text-align:center">具体消息</th></tr></thead><tbody><tr><td style="text-align:center">WM_MOUSEMOVE</td><td style="text-align:center">EX_MOUSE</td><td style="text-align:center">鼠标移动消息</td></tr><tr><td style="text-align:center">WM_MOUSEWHEEL</td><td style="text-align:center">EX_MOUSE</td><td style="text-align:center">鼠标滚轮拨动消息</td></tr><tr><td style="text-align:center">WM_LBUTTONDOWN</td><td style="text-align:center">EX_MOUSE</td><td style="text-align:center">左键按下消息</td></tr><tr><td style="text-align:center">WM_LBUTTONUP</td><td style="text-align:center">EX_MOUSE</td><td style="text-align:center">左键弹起消息</td></tr><tr><td style="text-align:center">WM_LBUTTONDBLCLK</td><td style="text-align:center">EX_MOUSE</td><td style="text-align:center">左键双击消息</td></tr><tr><td style="text-align:center">WM_MBUTTONDOWN</td><td style="text-align:center">EX_MOUSE</td><td style="text-align:center">中键按下消息</td></tr><tr><td style="text-align:center">WM_MBUTTONUP</td><td style="text-align:center">EX_MOUSE</td><td style="text-align:center">中键弹起消息</td></tr><tr><td style="text-align:center">WM_MBUTTONDBLCLK</td><td style="text-align:center">EX_MOUSE</td><td style="text-align:center">中键双击消息</td></tr><tr><td style="text-align:center">WM_RBUTTONDOWN</td><td style="text-align:center">EX_MOUSE</td><td style="text-align:center">右键按下消息</td></tr><tr><td style="text-align:center">WM_RBUTTONUP</td><td style="text-align:center">EX_MOUSE</td><td style="text-align:center">右键弹起消息</td></tr><tr><td style="text-align:center">WM_RBUTTONDBLCLK</td><td style="text-align:center">EX_MOUSE</td><td style="text-align:center">右键双击消息</td></tr><tr><td style="text-align:center">WM_KEYDOWN</td><td style="text-align:center">EX_KEY</td><td style="text-align:center">按键按下消息</td></tr><tr><td style="text-align:center">WM_KEYUP</td><td style="text-align:center">EX_KEY</td><td style="text-align:center">按键弹起消息</td></tr><tr><td style="text-align:center">WM_CHAR</td><td style="text-align:center">EX_CHAR</td><td style="text-align:center">字符消息</td></tr><tr><td style="text-align:center">WM_ACTIVATE</td><td style="text-align:center">EX_WINDOW</td><td style="text-align:center">窗口激活状态改变消息</td></tr><tr><td style="text-align:center">WM_MOVE</td><td style="text-align:center">EX_WINDOW</td><td style="text-align:center">窗口移动消息</td></tr><tr><td style="text-align:center">WM_SIZE</td><td style="text-align:center">EX_WINDOW</td><td style="text-align:center">窗口大小改变消息</td></tr></tbody></table><p>共用体union用于检测哪个键被按下，其与消息类别相关。</p><h2 id="5-2-消息的获取">5.2. 消息的获取</h2><p>首先来了解peekmessage函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">peekmessage</span><span class="params">(ExMessage *pmsg,BYTE filter = <span class="number">-1</span>,<span class="type">bool</span> removemsg =<span class="literal">true</span>)</span>;</span><br></pre></td></tr></table></figure><p>函数若收到消息,则返回true;否则返回false;<br>pmsg指针用于保存获取到的信息;<br>filter默认为-1表示接收所有输入,将-1替换成下表所示参数可限制获取指定类别的消息:</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">限制</th></tr></thead><tbody><tr><td style="text-align:center">EX_MOUSE</td><td style="text-align:center">鼠标消息</td></tr><tr><td style="text-align:center">EX_KEY</td><td style="text-align:center">按键消息</td></tr><tr><td style="text-align:center">EX_CHAR</td><td style="text-align:center">字符消息</td></tr><tr><td style="text-align:center">EX_WINDOW</td><td style="text-align:center">窗口消息</td></tr></tbody></table><p>removemsg控制peekmessage处理完毕后是否将其从消息队列移除。(可以不写)<br>实际应用时，按照下面的示例写即可:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExMessage msg;<span class="comment">//一定要定义一个ExMessage变量</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//一直监听</span></span><br><span class="line">&#123;</span><br><span class="line">    peekmessage(&amp;msg,EX_MOUSE|EX_KEY);<span class="comment">//获取鼠标和键盘的输入并记录在msg中</span></span><br><span class="line">    <span class="keyword">if</span>(msg.message == WM_KEYDOWN)<span class="comment">//键盘是否按下？</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(msg.vkcode == <span class="string">&#x27;Z&#x27;</span>)<span class="comment">//按的是Z吗？</span></span><br><span class="line">        &#123;</span><br><span class="line">            ···<span class="comment">//执行语句</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此EasyX的基础操作已经完毕。</p><h1>6. 音频的播放</h1><p>EasyX只提供图形界面的功能，音频播放需导入其它的头文件和库。<br>可以用.mp3与.wav</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span> <span class="comment">//导入系统接口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mmsystem.h&gt;</span> <span class="comment">//导入系统多媒体头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;winmm.lib&quot;</span>); <span class="comment">//导入库文件,注意分号</span></span></span><br></pre></td></tr></table></figure><h2 id="6-1-导入音乐">6.1. 导入音乐</h2><p>右击解决方案下面的项目名，选择&quot;在文件资源管理器中打开文件夹&quot;<br>这样打开了项目目录，向项目目录中拖入.mp3文件，再用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mciSendString(<span class="string">&quot;open music.mp3&quot;</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);<span class="comment">//同级目录</span></span><br><span class="line">mciSendString(<span class="string">&quot;open music.mp3 alias bgm1&quot;</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);<span class="comment">//alias取别名</span></span><br></pre></td></tr></table></figure><p>打开音乐，但还未播放;再用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mciSendString(<span class="string">&quot;play music.mp3&quot;</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">mciSendString(<span class="string">&quot;play bgm1&quot;</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);<span class="comment">//别名</span></span><br></pre></td></tr></table></figure><p>播放音乐。若要关闭音乐,则用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mciSendString(<span class="string">&quot;close music.mp3&quot;</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h2 id="6-2-调整音量">6.2. 调整音量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mciSendString(<span class="string">&quot;setaudio bgm1 volume to 90 &quot;</span>)<span class="comment">//volume的数值可取0到1000,标准为100</span></span><br></pre></td></tr></table></figure><h2 id="6-3-定义函数">6.3. 定义函数</h2><p>籍此，我们可以定义一个函数方便实现音乐的播放：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PlayBGM</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *music)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> cmd[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(cmd,<span class="string">&quot;open %s alias bgm&quot;</span>,music);<span class="comment">//将指令打印到cmd[]中</span></span><br><span class="line">MCIERROR ret = mciSendString(cmd,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);<span class="comment">//类似scanf,导入音乐的同时检测是否成功(成功返回0)</span></span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> err[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">mciGetErrorString(ret,err,<span class="keyword">sizeof</span>(err));<span class="comment">//获取错误信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;openERROR:%s&quot;</span>,err);</span><br><span class="line">&#125;</span><br><span class="line">mciSendString(<span class="string">&quot;play bgm&quot;</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数可以用诸如setaudio的功能拓展。</p><h2 id="6-4-音效播放">6.4. 音效播放</h2><p>使用PlaySound()函数实现音效播放:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlaySound(<span class="type">char</span> *fllename,<span class="literal">NULL</span>,SND_FILENAME|SND_ASYNC);</span><br></pre></td></tr></table></figure><p>仅支持.wav音乐，输入文件名加后面参数即可。</p><h1>7.双缓冲</h1><p>EasyX的画图没有对象，也就是说需要把之前的图片清除(清屏)再重绘画面，这样会导致闪屏，于是双缓冲的机制出现了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeginBatchDraw();</span><br><span class="line">FlushBatchDraw();</span><br></pre></td></tr></table></figure><p>上面的函数开始绘图，保存在内存中，下面的函数负责输出画面。<br>也不是很难。</p><p>题外话：动效的实现可以通过坐标的改变，重新绘制画面以及sleep函数实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sleep(<span class="type">unsigned</span> <span class="type">int</span> t);<span class="comment">//t为毫秒，于windows.h头文件中</span></span><br></pre></td></tr></table></figure><hr><p>庆祝舞萌w2！！！🎆🎆🎆</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 图形库 </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于C指针</title>
      <link href="/2024/11/27/%E5%85%B3%E4%BA%8EC%E6%8C%87%E9%92%88/"/>
      <url>/2024/11/27/%E5%85%B3%E4%BA%8EC%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1>0. 声明</h1><p>本文需要读者对指针有基本的了解，在叙述方面将会有所省略。</p><h1>1. 基础知识</h1><h2 id="1-1-间接寻址运算符">1.1. 间接寻址运算符&quot;*&quot;</h2><p>&quot;*&quot;在声明指针变量时与其它情况表示的意思不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p; <span class="comment">//告诉电脑p是一个指针</span></span><br><span class="line">*p=a; <span class="comment">//取p所指向的变量值</span></span><br></pre></td></tr></table></figure><h2 id="1-2-指针的基类型">1.2. 指针的基类型</h2><p>指针变量在声明时具有基类型，一个指针变量只能指向具有同一基类型的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p=&amp;a; <span class="comment">//正常</span></span><br><span class="line">p=&amp;b; <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><h2 id="1-3-关于NULL">1.3. 关于NULL</h2><p>空指针：值为NULL(注意都要大写)的指针。<br>如果不知道指针指向哪里，建议将其初始化为NULL。这样做的好处：</p><ol><li>明确说明变量是一个指针变量；</li><li>某些编译器为空指针使用不存在的内存地址，这样做可以防止崩溃；</li><li>避免野指针的出现。</li></ol><h1>2. 指针与函数</h1><h2 id="2-1-指针做函数参数">2.1. 指针做函数参数</h2><p>指针做函数参数时，函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; Fuct(*p); <span class="comment">//表示该函数接收一个指针（地址），在调用时传入指针变量或用&quot;&amp;&quot;运算符对变量取的地址</span></span><br></pre></td></tr></table></figure><p>指针变量做函数参数，函数可以直接对该变量进行修改。<br>需要明确的一点是，指针与指针指向变量的值不是一个概念。如这个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *p1,<span class="type">int</span> *p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *temp;</span><br><span class="line">    temp=p1;</span><br><span class="line">    p1=p2;</span><br><span class="line">    p2=temp;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个swap函数仅在内部交换了两个指针变量的指向，它们指向变量的值并未改变，所以这个函数是错误的。</p><h2 id="2-2-函数指针">2.2. 函数指针</h2><p>函数指针是指向函数的指针。函数指针的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; (*p) (形参列表);</span><br><span class="line"><span class="comment">//函数指针的类型和形参列表需与其指向的函数完全一致（不建议省略形参列表），即若有</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">//则可声明指向Func函数的指针</span></span><br><span class="line"><span class="type">int</span> (*f)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">f=Func;<span class="comment">//不带&quot;()&quot;的Func将被理解为函数的入口地址，f存储了Func函数的入口地址</span></span><br></pre></td></tr></table></figure><p>如果不这么写呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">f</span> <span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="comment">//这将声明一个函数，它的返回值是一个整型指针</span></span><br><span class="line"><span class="type">int</span> (*f);</span><br><span class="line"><span class="comment">//这仅仅定义了一个整型指针，跟括号没半毛钱关系</span></span><br></pre></td></tr></table></figure><p>函数指针用于编写通用性更强的函数，如在排序算法中同时支持升序和降序两种排列方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不使用函数指针：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AscendingSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DescendingSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="comment">//如果使用函数指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n,<span class="type">int</span> (*cmp)(<span class="type">int</span>,<span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (cmp(a[j],a[k]))&#123;k=j&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Ascending(<span class="type">int</span> a,<span class="type">int</span> b);&#123;<span class="keyword">return</span> a&lt;b;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Descending</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;&#123;<span class="keyword">return</span> a.b;&#125;</span><br></pre></td></tr></table></figure><p>使用函数指针将大大减少代码的重复性。</p><h1>3. 指针与数组</h1><h2 id="3-1-指针与一维数组">3.1. 指针与一维数组</h2><p>一维数组的数组名就是它第一个元素的首地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;arr[<span class="number">0</span>],arr<span class="comment">//代表同一个地址</span></span><br><span class="line">p=&amp;arr[<span class="number">0</span>];</span><br><span class="line">p=arr;<span class="comment">//这两个表达是等价的</span></span><br></pre></td></tr></table></figure><h2 id="3-2-指针的算术运算">3.2. 指针的算术运算</h2><p>如果指针有意义(指向数组)，则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p++;<span class="comment">//访问下一元素，加的值为sizeof(&lt;type&gt;)</span></span><br><span class="line">p--;<span class="comment">//访问上一元素，减的值为sizeof(&lt;type&gt;)</span></span><br><span class="line">p2-p1;<span class="comment">//计算指针间距离，值为下标距离</span></span><br><span class="line">p&gt;q;<span class="comment">//比较两元素的相对位置</span></span><br></pre></td></tr></table></figure><p>可以看出，指针在某种意义上就是数组的下标，因此可以用指针的算术运算访问数组元素。</p><h2 id="3-3-两个容易混淆的概念">3.3. 两个容易混淆的概念</h2><h3 id="3-3-1-数组指针与指针数组">3.3.1. 数组指针与指针数组</h3><p>优先级上，()&gt;[]&gt;*, 因此</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>];<span class="comment">//先判定()内，p是个指针，类型为int[3],其步长就为3*sizeof(int)</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">3</span>];<span class="comment">//没有括号就先判定[],p是个数组，数组的元素类型为指针，其步长就为sizeof(int*)</span></span><br></pre></td></tr></table></figure><p>由此可见，数组指针就是指向数组的指针，而指针数组就是存储了指针的数组，还挺顾名思义的。</p><h3 id="3-3-2-指针常量与常量指针">3.3.2. 指针常量与常量指针</h3><p>继续顾名思义，指针常量首先得是个常量，其次它才是个指针；而常量指针首先得是个指针，其次它才是个常量。<br>那也就是说，指针常量的地址不可以被修改，而常量指针所指的值不可以被修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> q=&amp;a;<span class="comment">//声明了一个指针常量q，指向a</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p=&amp;a;<span class="comment">//声明了一个常量指针p，指向a</span></span><br><span class="line">*q=<span class="number">10</span>;<span class="comment">//正常，q的指向未改变</span></span><br><span class="line">q=&amp;b;<span class="comment">//报错，q的指向不能改变</span></span><br><span class="line">*p=<span class="number">10</span>;<span class="comment">//报错，p所指向的值不能改变</span></span><br><span class="line">p=&amp;b;<span class="comment">//正常，p原来指向的值未改变</span></span><br></pre></td></tr></table></figure><h2 id="3-4-指针与二维数组">3.4. 指针与二维数组</h2><h3 id="3-4-1-二维数组的行指针">3.4.1. 二维数组的行指针</h3><p>如果把二维数组的每行拆开，则二维数组实际上是一个指针数组，其存储了二维数组每一行对应的一维数组的数组名（首地址）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">2</span>][<span class="number">3</span>]--&gt;a[<span class="number">0</span>],a[<span class="number">1</span>]<span class="comment">//a[0]和a[1]都是数组名(地址)</span></span><br><span class="line">a[<span class="number">0</span>]--&gt;a[<span class="number">0</span>][<span class="number">0</span>],a[<span class="number">0</span>][<span class="number">1</span>],a[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">a[<span class="number">1</span>]--&gt;a[<span class="number">1</span>][<span class="number">0</span>],a[<span class="number">1</span>][<span class="number">1</span>],a[<span class="number">1</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>因此，若要给出二维数组的行指针（假设数组是int数组），则指针的基类型应该是一个int数组，其元素个数与列数相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>];</span><br><span class="line">p=a; <span class="comment">//或p=&amp;a[0],这里的a[0]是地址，可以看出a=&amp;a[0](行)</span></span><br></pre></td></tr></table></figure><p>如此声明会将p指向二维数组的第零行（注意此时还没有值）。<br>若想获得某行某列元素的的值，需要再解一次指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p+i;<span class="comment">//指向二维数组行一维数组的数组名(还未解出)</span></span><br><span class="line">*(p+i);<span class="comment">//解出第i行(从0数起)的数组名(地址)</span></span><br><span class="line">*(p+i)+j;<span class="comment">//指向二维数组第i行第j列的元素(还未解出)</span></span><br><span class="line">*(*(p+i)+j);<span class="comment">//解出a[i][j]的值(完成)</span></span><br></pre></td></tr></table></figure><p>若要将行指针作为函数参数，需要声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; Func(<span class="type">int</span> (*p)[row]);<span class="comment">//列数不可省略且必须为常量</span></span><br></pre></td></tr></table></figure><h3 id="3-4-2-二维数组的列指针">3.4.2. 二维数组的列指针</h3><p>二维数组实际上在内存中按一行一行存储，因此二维数组的本质还是一维数组，只不过引入了偏移量的概念。因此第i行第j列(从0数起)的元素实际上就是第i*n+j个元素。因此</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=a;<span class="comment">//p现在是一个一维指针（注意不是指针数组）</span></span><br><span class="line">*(p+i*n+j);<span class="comment">//就是a[i][j]的值</span></span><br></pre></td></tr></table></figure><p>若要将列指针作为函数参数，需要声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; Func(<span class="type">int</span> *p);<span class="comment">//当成一维指针用就好</span></span><br></pre></td></tr></table></figure><h1>4. 指针与字符串</h1><h2 id="4-1-字符数组与字符指针">4.1. 字符数组与字符指针</h2><p>以’\0’结尾的字符数组(char类型)是字符串。('\0’的ASCII码为0，而’0’为48)<br>字符数组可以用逐个赋值的方法初始化，也可以直接赋字符串(需保证长度为字符串长度+1)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;hello&quot;</span>;<span class="comment">//这两种赋值方法等价</span></span><br></pre></td></tr></table></figure><p>字符指针 char *p 是指向字符串首地址的指针，与数组的arr=&amp;arr[0]如出一辙。<br>需要注意的是，尽管指针与数组间有极大的相似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p=<span class="string">&quot;Hello&quot;</span>;<span class="comment">//&quot;Hello&quot;这个内容不能修改，因为是常量</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;Hello&quot;</span>;<span class="comment">//str的指向不能修改，因为是数组名(常量)</span></span><br></pre></td></tr></table></figure><h2 id="4-2-字符串的输入">4.2. 字符串的输入</h2><p>常用的命令有scanf,gets与fgets。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);<span class="comment">//这种方法不会包含空格，且末尾回车会留在缓冲区，可用getchar()清空缓冲区</span></span><br><span class="line">gets(str);<span class="comment">//这种方法会包含空格，末尾回车会被读走</span></span><br><span class="line">fgets(str,n,<span class="built_in">stdin</span>);<span class="comment">//这种方法会包含空格，末尾回车会被读走，最多读取n-1个字符，最后会自动加&#x27;\0&#x27;,且可以指定从哪个流读取字符</span></span><br></pre></td></tr></table></figure><h2 id="4-3-字符串处理函数">4.3. 字符串处理函数</h2><p>由于字符串的本质还是数组，因此不能拿它当变量操作。<br>主要用到的字符串处理函数(包含在&lt;string.h&gt;中)<br>注意：这些处理函数全是对字符串进行操作，而非字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(str);<span class="comment">//返回字符串长度，不包含结尾&#x27;\0&#x27;那一位</span></span><br><span class="line"><span class="built_in">strcpy</span>(str1,str2);<span class="comment">//将str2复制到str1，需要str1足够大</span></span><br><span class="line"><span class="built_in">strcat</span>(str1,str2);<span class="comment">//将str2连接到str1后，str1会取消原来末尾的&#x27;\0&#x27;</span></span><br><span class="line"><span class="built_in">strcmp</span>(str1,str2);<span class="comment">//比较str1和str2，从前往后比，直到出现一对不相等的字符，由它们俩的ASCII码的差值决定返回值，故返回值为0表示相等，返回值为正表示str1&gt;str2，返回值为负表示str1&lt;str2</span></span><br></pre></td></tr></table></figure><h2 id="4-4-函数与字符串">4.4. 函数与字符串</h2><p>向函数传递字符串，可以传递字符数组也可以传递字符指针。这两种方法都是传字符串的首地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Read</span><span class="params">(<span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*p==<span class="string">&#x27;M&#x27;</span>)&#123;...&#125;<span class="comment">//读取第一个命令</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要从函数返回字符串，可以用数组或指针做函数形参、从函数返回指向字符串的指针(定义时就声明，一般是已经分配好的地址)。</p><h1>5. 指针与结构体</h1><h2 id="5-1-结构体指针">5.1. 结构体指针</h2><p>结构体指针用结构体名作为类型，指向同种结构体的第一个元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STUDENT stu1;</span><br><span class="line">STUDENT *pt;</span><br><span class="line">pt=&amp;stu1;<span class="comment">//pt指向stu1的第一个元素，对结构体取地址用&quot;&amp;&quot;</span></span><br><span class="line">(*pt).studentID=<span class="number">1</span>;<span class="comment">//相当于stu1.studentID=1</span></span><br></pre></td></tr></table></figure><p>如果是结构体数组，则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">STUDENT stu[<span class="number">20</span>];</span><br><span class="line">STUDENT *pt=stu;<span class="comment">//与STUDENT *pt=&amp;stu[0]等价</span></span><br><span class="line">(*pt).studentID=<span class="number">1</span>;<span class="comment">//相当于stu[0].studentID=1</span></span><br><span class="line">pt++;<span class="comment">//将pt指向stu[1]</span></span><br></pre></td></tr></table></figure><h2 id="5-2-向函数传递结构体">5.2. 向函数传递结构体</h2><p>向函数传递结构体可以传递结构体的自身的完整或局部，也可以向函数传递结构体指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Func</span><span class="params">(POINT pt)</span>;<span class="comment">//修改结果不影响到实参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Func</span><span class="params">(POINT *pt)</span>;<span class="comment">//修改结果影响实参</span></span><br></pre></td></tr></table></figure><p>当然，结构体及其指针也可以做函数的返回值，但较推荐返回指针。</p><h1>6. 链表</h1><h2 id="6-1-链表及其创建">6.1. 链表及其创建</h2><p>链表是在结构体内部用这种结构体类型的指针实现散点文件链接存储的数据结构。其结构为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DATA data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，每个节点的指针域存储下一个节点的地址。头指针指向第一个节点，尾节点指针域为NULL。<br>在创建链表的过程中，需要包含以下逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pt=(PLAYER*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PLAYER));<span class="comment">//每次都分配新pt内存</span></span><br><span class="line">prePt-&gt;next=Pt;<span class="comment">//将prePt现在所指结构体的指针域指向Pt所对应的(下一个)节点</span></span><br><span class="line">prePt=Pt;<span class="comment">//将Pt赋值给prePt以进行下次循环</span></span><br></pre></td></tr></table></figure><h2 id="6-2-链表的查找">6.2. 链表的查找</h2><p>查找尾节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PLAYER *<span class="title function_">FindLast</span><span class="params">(PLAYER *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    PLAYER *pr;</span><br><span class="line">    pr=head;<span class="comment">//创建head指针的备份</span></span><br><span class="line">    <span class="keyword">while</span>(pr-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pr=pr-&gt;next;<span class="comment">//若当前不是尾节点，则移动指针到下一个节点：pr-&gt;next会访问下一节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找一般节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PLAYER *<span class="title function_">FindNode</span><span class="params">(PLAYER *head,<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    PLAYER *Pt=head;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;index &amp;&amp; Pt!=<span class="literal">NULL</span>)<span class="comment">//查找到n &amp;&amp; 在链表内</span></span><br><span class="line">    &#123;</span><br><span class="line">        Pt=Pt-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Pt;<span class="comment">//若找到，则正常返回；若超出范围，则返回空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-链表的插入">6.3. 链表的插入</h2><p>向尾节点后面插入节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PLAYER *<span class="title function_">Insert</span><span class="params">(PLAYER *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    PLAYER *prept *pt;</span><br><span class="line">    pt=(PLAYER*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PLAYER));<span class="comment">//为pt分配PLAYER空间用于存储输入</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pt-&gt;account);<span class="comment">//输入pt指向PLAYER空间信息</span></span><br><span class="line">    prept=FindLast(head);<span class="comment">//prept指向为尾节点的头</span></span><br><span class="line">    prept-&gt;next=pt;<span class="comment">//prept的指针域指向pt</span></span><br><span class="line">    pt-&gt;next=<span class="literal">NULL</span>;<span class="comment">//令pt成为新的尾节点</span></span><br><span class="line">    <span class="keyword">return</span> head;<span class="comment">//返回更新后的链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向一般节点后插入节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PLAYER *<span class="title function_">Insert</span><span class="params">(PLAYER *head,<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    PLAYER *prept *pt;</span><br><span class="line">    pt=(PLAYER*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PLAYER));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pt-&gt;account);<span class="comment">//至此同上</span></span><br><span class="line">    prept=FindNode(head,index);<span class="comment">//prept指向index号节点</span></span><br><span class="line">    <span class="keyword">if</span>(prept!=<span class="literal">NULL</span>)<span class="comment">//如果不是空指针</span></span><br><span class="line">    &#123;</span><br><span class="line">    pt-&gt;next=prept-&gt;next;<span class="comment">//将pt的指针域指向prept的下一个节点</span></span><br><span class="line">    prept-&gt;next=pt;<span class="comment">//将prept指向节点的指针域指向pt</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;node not exists&quot;</span>);&#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-链表的删除">6.3. 链表的删除</h2><p>删除节点，就是将节点从链表中摘下来，恢复前后关系后释放节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PLAYER *<span class="title function_">Delete</span><span class="params">(PLAYER *head, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    PLAYER *pt=<span class="literal">NULL</span>,*prept=<span class="literal">NULL</span>;</span><br><span class="line">    prept=FindNode(head,index<span class="number">-1</span>)<span class="comment">//寻找要删除节点的上一个节点，因为前驱节点位置难获取</span></span><br><span class="line">    pt=prept-&gt;next;<span class="comment">//pt指向这个待删除节点</span></span><br><span class="line">    <span class="keyword">if</span>(pt!=<span class="literal">NULL</span>)<span class="comment">//删除的节点是否存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        prept-&gt;next=pt-&gt;next;<span class="comment">//前驱节点的直接指向后继节点，在一般链表的访问中已经无法访问待删除的节点</span></span><br><span class="line">        <span class="built_in">free</span>(pt);<span class="comment">//释放pt指向的空间，删除待删除的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;node not exists&quot;</span>);&#125;</span><br><span class="line">    <span class="keyword">return</span> head;<span class="comment">//返回更新后的链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见这个方法对尾节点也有效。</p><h1>结尾</h1><p>你说得对，但是舞萌DX国服将于12月4日10:00更新「系ぎて」,我要去拆机了</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
